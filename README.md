# 🍚 Make Lunch Group!🍚
*이름을 등록하면 랜덤으로 점심 그룹을 만들어주는 서비스입니다*

![Findicle](/readme-assets/random-lunch-grouping.gif)

## Table of contents
1. [Feature](#feature)
2. [How to use](#how-to-use)
3. [How to run](#how-to-run)
4. [Tech Stack](#tech-stack)
5. [Architecture](#architecture)
6. [New Challenge](#new-challenge)
7. [Logs](#logs)
8. [Comment](#comment)
---
## 📌 Feature
1. 점심을 함께 할 사람의 이름을 추가하거나 삭제할 수 있고 이름 카드 리스트를 확인 할 수 있습니다.
2. 최소 그룹 인원 수와 원하는 그룹 수를 입력하면 랜덤으로 점심 그룹을 만들어줍니다.
3. 다시하기 버튼을 클릭해서 그룹을 재생성 할 수 있습니다.
---
## 🎯 How to use
- **이름 추가/삭제**
  - 왼쪽 사이드 폼에서 이름을 입력하여 이름 카드를 생성 할 수 있습니다.
  - 중복된 이름으로는 이름 카드를 생성 할 수 없습니다.
  - 생성된 이름 카드 하단에 있는 `delete` 버튼을 클릭하여 이름 카드를 삭제 할 수 있습니다.

- **그룹의 최소 인원 수와 그룹 수 입력**
  - 중앙에 있는 폼에서 최소 인원 수와 그룹 수를 입력 할 수 있습니다.
  - 입력 값이 1부터 10까지의 수가 아니거나 문자를 입력하면 안내 문구가 보입니다.
  - 그룹 리스트를 생성 할 수 없는 값을 입력하면 알림 메세지가 보입니다.
  - `Make Group!` 버튼을 클릭하면 결과 페이지로 이동 후 생성된 그룹 리스트를 볼 수 있습니다.

- **그룹 리스트 확인과 그룹 재생성**
  - 결과 페이지에서 점심 그룹 리스트를 확인 할 수 있습니다.
  - `Again!` 버튼을 클릭하면 랜덤 그룹이 재생성됩니다.
  - `Go Back` 버튼을 클릭하면 이전 페이지로 이동 할 수 있습니다.
  - 앞으로 가기 버튼을 클릭하면 결과가 그대로 남아있습니다.
---
## 🏃‍♀️ How to run
- **Installation**

  - [MongoDB Atlas](https://www.mongodb.com/cloud/atlas)에서 MongoDB URL 발급 후 env 파일에 입력

  ```
  npm install

  npm start
  npm run start:server
  ```
1. 환경 변수를 .env.sample에 맞게 입력합니다.
2. npm install을 통해 패키지를 설치합니다.
3. 터미널에서 `npm start`와 `npm run start:server` 로 실행할 수을 확인할 수 있습니다.
---
##  📐Architecture
- **client**
  - 아토믹 디자인 패턴으로 컴포넌트를 분리를 하였습니다. 이전 프로젝트에서는 기준을 명확하게 구분하는 것이 어려웠지만 이번 과제를 통해서 아토믹 디자인 패턴으로 컴포넌트 구성하면서 UI구현에 구조적으로 접근 할 수 있어서 좋았고 작은 단위로 시작해서 큰단위로 조립을 하듯 완성되는 과정에서 진행 사항을 더 직관적으로 볼 수 있었습니다.
- **server**
  - 컨트롤러에서 비즈니스 로직을 서비스 디렉토리로 분리 하였습니다. 관심사 분리를 통해 복잡했던 컨트롤러의 역할을 조금 더 분명하게 정의 할 수 있었습니다. 이번 과제에서는 비지니스 로직이 많지 않아 더 번거로운 작업이 될 수있지만 규모가 큰 프로젝트에서는 더 나은 방향이라고 생각합니다.
---
## 💻 Tech Stack
- **Frontend**
   - TypeScript
   - React
   - React-router-dom
   - Redux (Reduxjs/toolkit)
   - Redux-thunk
   - Styled-components
   - Eslint
   - React-Testing-Library
- **backend**
   - NodeJs
   - Express
   - MongoDB
   - Mongoose
---
## 😅 Logs
- ### *dispatch 함수와 리액트의 사이클 문제*
  최상단에 있는 APP 페이지에서 랜덤 그룹리스트를 만드는 알고리즘을 폼에서 입력 받은 최소 인원수와 그룹 수를 스토어에서 가져와 인자로 넘겨 주어 실행시키는 핸들러를 `<GroupingForm />`와 `<ResultPage />`의 `onSubmit`에 넘겨주었습니다. 그룹 리스트를 최초 생성 할 때와 재생성할 때 같은 핸들러를 사용하게끔해서 중복 핸들러를 제거했습니다. 하지만 최초 생성 버튼 핸들러로 `onSubmit`을 실행하고 `/result`페이지로 라우팅되었지만 랜덤 그룹 리스트가 랜더링이 되지 않는 문제를 발견하였습니다. 혹시 `useHistory`를 이용한 라우팅이 먼저실행이 되어 빈 페이지가 보여지는 것인지, 폼에서 입력 받은 값이 dispatch가 되지 않는건지, 여러가지 랜더링 문제를 염두해서 디버깅을 한 결과, 입력 받은 값을 dispatch한 다음에 라우팅 함수가 실행되지 않고 라우팅이 된 후 dispatch 함수가 실행이되는 문제를 발견 할 수 이었습니다.
  코드가 동기적으로 작동하지 않는것처럼 보여 서치를 한 결과 dispatch 사이클과 리액트 랜더링 사이클이 분리되어 작동 되기 때문에 동기적으로 함수가 실행되어도 내부적으로 사이클이 어긋나서 발생한 문제라는 것을 알 수 있었습니다. `/result`로 라우팅이 될 때 입력 값이 dispatch되지 않아서 빈 페이지가 보여진 것이었습니다.
  초기에 최소 인원수 값과 그룹 수 값을 global state로 관리하여 `<GroupingForm />과 <ResultPage />`의 알고리즘 실행에 사용했지만 `<App />` 의 local state로 관리하여 state를 내려주는 방법으로 변경하였고, dispatch 사이클의 영향을 받지 않고 상위에서 하위로 상태를 내려주는 안정적인 데이터 흐름 측면에서도 나은 방향으로 해결하였습니다.
  항상 global state와 local state의 기준과 dispatch의 라이프 사이클에 대해서 고민할 수 있었던 부분입니다.

- ### *랜더링 최적화 - React.memo와 useSelector Hook*
  처음에 최소 인원수와 그룹 수를 global state로 관리했을 때 `<GroupingForm />`의 input에 값을 입력할 때마다 `<AsideBoard />`와 `<NameList />`가 불필요한 랜더링이 발생하였습니다. 이유는 `useSelector` Hook을 이용해 `people` state를 바라보고 있기 때문에 상위 컴포넌트에서 state가 변화하면 이를 감지하여 하위 컴포넌트가 재랜더링 되기 때문이었습니다. 그래서 최적화의 필요성을 느꼈고 `React.memo`를 이용해서 컴포넌트를 감싸주었습니다. 하지만 `React.memo`도 결국 캐싱을 하여 메모리 공간을 사용하는 것이기 때문에 완벽하게 최적화가 되었다고 볼수 없어서 실제로 성능을 테스트 해보지 않는 이상 `React.memo`를 사용하는 것이 옳바른 최적화 방법인지에 대해서는 조금 더 고민해야할 부분이라고 생각합니다. 그리고 서치를 통해 `useSelector` Hook으로 상태를 조회할 때 state를 더 세밀하게 분해해서 `useSelector` Hook을 여러개 사용함으로서 state 변화 감지를 최소화 시킬 수 있다는 점을 알게되었습니다.

- ### *랜덤 알고리즘과 Map 자료구조*
  최소 인원수, 그룹 수, 총 인원을 기준으로 `getRandomGroupList`알고리즘을 구현하였습니다. 총 인원 수만큼의 키값을 요소로 담겨있는 랜덤 배열을 만들기 위해서 랜덤으로 일반 객체에 랜덤숫자를 할당을 하였는데 순서가 보장이 되지 않는 점 때문에 객체 내부에서 정렬이 되어 랜덤 배열을 만들 수 없었습니다. 그래서 순서가 보장이 되는 Map 자료구조를 사용하여 랜덤 배열을 만들 수 있었습니다.
  ```
  //1. 키값이 랜덤으로 담겨있는 배열로 만들어줍니다.
  const randomKeyList = [3, 0, 4, 1, 2, 6, 5];

  //2. 최소 인원 수 만큼 인자를 그룹 배열에 넣고 그룹 리스트 배열에 담아줍니다. 최소인원 수 2, 그룹수 3
  const groupList = [[3, 0], [4, 1], [2, 6]];

  //3. 남은 인원을 랜덤 그룹 키에 해당하는 그룹에 넣어줍니다.
  const groupList = [[3, 0], [4, 1, 5], [2, 6]];
  ```
---
## 🏹 New Challenge
### *Typescript*
타입스크립트를 처음 사용하면서 Redux-Thunk와 Redux-Toolkit 외 여러 라이브러리의 보일러 플레이트 설정과 컴포넌트를 만들 때마다  `interface`를 만들고 `Type`을 지정 해주어야히는 번거로움 때문에 초기 설정에 시간이 꽤 소요 되었습니다. 하지만 `Type`을 지정함으로써 컴파일 단계에서 에러를 발견 할 수 있다는 점에서  타입스크립트를 사용하기 이전 런 타임 때 props와 state로 인한 오류로 새로고침을 하고 디버깅을 하면서 낭비 했던 물리적인 시간을 줄일 수 있었습니다. 짧은 시간내에 적용하다보니 돔의 확장성을 고려하지 못한 커스텀 인터페이스와 로컬스테이트의 타입 미지정 등 더 상세하게 타입을 설정하지 못한점등이 아쉬웠습니다.

### *Redux-Thunk*
이번 과제를 통해 Redux-Thunk를 처음 사용하면서 가장 좋았던 점은 컴포넌트에서 비동기요청 로직을 분리함으로서 컴포넌트가 Thunk 함수내에서 처리함으로서 dispatch만으로 컴포넌트에서 비즈니스 로직을 분리함으로서 굉장히 코드가 간결해져 가독성이 좋아졌고 관심사 분리 관점에서도 함수형프로그래밍에 더 가까운 코드를 작성할 수 있었습니다. API요청 등 비동기 처리가 많은 프로젝트를 진행할 때 훨씬 더 이점을 느낄 수 있는 로직 처리 방식이라고 생각했습니다.

---
## 💡 Comment
우선 이번 과제를 통해 Typescript와 Redux-thunk를 적용 할 수 있는 새로운 시도를 할 수 있어 서 좋았습니다. 처음 사용하는 기술이라 부족한 점이 많지만 차후 더 개선할 수 있는 방향으로 깊게 공부를 할 수있는 계기가 되었습니다. 또한 과제의 기능은 적지만 구현 하면서 프로그래밍의 핵심에 대해 더 깊은 고민을 할 수 있었습니다. 컴포넌트 분리, 데이터 구조, 데이터 가공을 위한 랜덤 알고리즘 등 더 나은 방향으로 구현하기 위해 많은 의구심과 호기심을 갖고 접근하였습니다. 전형을 위한 과제였지만 저에게 많은 도움이 되었던 좋은 과제였습니다. 감사합니다.
